<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Content Eingabe & Review</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .status-message {
        transition: opacity 0.3s ease;
      }
      .loading-spinner {
        border: 2px solid #f3f3f3;
        border-top: 2px solid #3498db;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 8px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .rate-limit-timer {
        background: linear-gradient(to right, #ef4444, #f97316, #eab308);
        color: white;
        padding: 8px 16px;
        border-radius: 8px;
        font-weight: bold;
        text-align: center;
        margin: 8px 0;
      }
      .auto-resize {
        resize: vertical;
        overflow: hidden;
        min-height: 100px;
      }
      .post-action-buttons {
        display: flex;
        gap: 8px;
        margin-top: 12px;
      }
      .action-btn {
        padding: 8px 16px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        border: none;
      }
      .action-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .btn-post { background: #16a34a; color: white; }
      .btn-post:hover { background: #15803d; }
      .btn-schedule { background: #2563eb; color: white; }
      .btn-schedule:hover { background: #1d4ed8; }
      .btn-draft { background: #6b7280; color: white; }
      .btn-draft:hover { background: #4b5563; }
    </style>
  </head>
  <body class="bg-gray-100 p-6">
    <!-- Status Message Container -->
    <div id="status-container" class="max-w-3xl mx-auto mb-4"></div>

    <!-- Rate Limit Display -->
    <div id="rate-limit-container" class="max-w-3xl mx-auto mb-4" style="display: none;">
      <div class="rate-limit-timer">
        <span id="rate-limit-text"></span>
      </div>
    </div>

    <!-- Content Input Section -->
    <div class="max-w-3xl mx-auto bg-white rounded-2xl shadow p-6 mb-8">
      <div class="flex items-center justify-between mb-4">
        <img src="https://anyever.de/wp-content/themes/anyever/static/images/logo-anyever-gold.svg" alt="Any Ever Logo" class="h-12" />
        <div class="text-sm text-gray-500">
          Requests heute: <span id="daily-request-count">0</span>/20
        </div>
      </div>
      <h1 class="text-2xl font-bold mb-4">Content-Eingabe</h1>

      <input type="text" id="thema" class="border p-2 mb-4 w-full rounded" placeholder="Thema (Pflichtfeld)" required />
      <input type="text" id="subline" class="border p-2 mb-4 w-full rounded" placeholder="Subline (optional)" />
      <input type="url" id="url" class="border p-2 mb-4 w-full rounded" placeholder="Ziel-URL (optional)" />
      <input type="url" id="grafik_url" class="border p-2 mb-4 w-full rounded" placeholder="Grafik-URL (optional)" />

      <!-- Content Type Selection -->
      <div class="mb-4 p-4 bg-gray-50 rounded-lg">
        <h3 class="font-semibold mb-3">Content-Kan√§le ausw√§hlen (mindestens einen):</h3>
        <div class="grid grid-cols-2 gap-3">
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_linkedin" class="content-checkbox" checked />
            <span>LinkedIn Post</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_facebook" class="content-checkbox" checked />
            <span>Facebook Post</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_instagram" class="content-checkbox" checked />
            <span>Instagram Feed</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_instagram_reel" class="content-checkbox" />
            <span>Instagram Reel</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_blog" class="content-checkbox" checked />
            <span>Blog Artikel</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_podcast" class="content-checkbox" />
            <span>Podcast Skript</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_avatar" class="content-checkbox" />
            <span>Avatar Skript</span>
          </label>
        </div>
      </div>

      <div class="text-right">
        <button id="submit-btn" onclick="submitInputWithValidation()" class="bg-green-600 text-white px-6 py-3 rounded-xl shadow hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-medium">
          Inhalt √ºbermitteln
        </button>
      </div>
    </div>

    <!-- Content Review & Posting Section -->
    <div class="max-w-3xl mx-auto bg-white rounded-2xl shadow p-6">
      <h1 class="text-2xl font-bold mb-4">Content Review & Ver√∂ffentlichung</h1>

      <input type="text" id="input_id" style="position: absolute; left: -9999px; opacity: 0;" readonly />

      <div id="content-sections-container"></div>

      <div class="text-right mt-6">
        <button id="review-submit-btn" onclick="submitReview()" class="bg-blue-600 text-white px-6 py-3 rounded-xl shadow hover:bg-blue-700 font-medium" style="display: none;">
          Freigaben speichern
        </button>
      </div>
    </div>

    <script>
      // Global Variables & Rate Limiting
      const inputId = Date.now().toString();
      let isPolling = false;
      let rateLimitTimer = null;
      
      const RATE_LIMITS = {
        DAILY_MAX: 20,
        COOLDOWN_MINUTES: 5,
        STORAGE_KEY: 'content_generation_rate_limit'
      };

      // Rate Limiting Functions
      function checkRateLimit() {
        const now = Date.now();
        const today = new Date().toDateString();
        
        let rateLimitData = JSON.parse(localStorage.getItem(RATE_LIMITS.STORAGE_KEY) || '{}');
        
        // Reset daily counter if new day
        if (rateLimitData.date !== today) {
          rateLimitData = { date: today, count: 0, lastRequest: 0 };
        }
        
        // Check daily limit
        if (rateLimitData.count >= RATE_LIMITS.DAILY_MAX) {
          showErrorMessage(`Tageslimit erreicht (${RATE_LIMITS.DAILY_MAX} Requests). Versuchen Sie es morgen wieder.`);
          return false;
        }
        
        // Check cooldown
        const timeSinceLastRequest = now - rateLimitData.lastRequest;
        const cooldownMs = RATE_LIMITS.COOLDOWN_MINUTES * 60 * 1000;
        
        if (timeSinceLastRequest < cooldownMs) {
          const remainingTime = Math.ceil((cooldownMs - timeSinceLastRequest) / 1000);
          startCooldownTimer(remainingTime);
          return false;
        }
        
        return true;
      }
      
      function updateRateLimit() {
        const today = new Date().toDateString();
        let rateLimitData = JSON.parse(localStorage.getItem(RATE_LIMITS.STORAGE_KEY) || '{}');
        
        if (rateLimitData.date !== today) {
          rateLimitData = { date: today, count: 0, lastRequest: 0 };
        }
        
        rateLimitData.count++;
        rateLimitData.lastRequest = Date.now();
        
        localStorage.setItem(RATE_LIMITS.STORAGE_KEY, JSON.stringify(rateLimitData));
        document.getElementById('daily-request-count').textContent = rateLimitData.count;
      }
      
      function startCooldownTimer(seconds) {
        const container = document.getElementById('rate-limit-container');
        const text = document.getElementById('rate-limit-text');
        
        container.style.display = 'block';
        document.getElementById('submit-btn').disabled = true;
        
        const updateTimer = () => {
          if (seconds <= 0) {
            container.style.display = 'none';
            document.getElementById('submit-btn').disabled = false;
            return;
          }
          
          const minutes = Math.floor(seconds / 60);
          const secs = seconds % 60;
          text.textContent = `Cooldown aktiv: ${minutes}:${secs.toString().padStart(2, '0')} verbleibend`;
          
          seconds--;
          setTimeout(updateTimer, 1000);
        };
        
        updateTimer();
      }

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("input_id").value = inputId;
        
        // Load daily counter
        const today = new Date().toDateString();
        const rateLimitData = JSON.parse(localStorage.getItem(RATE_LIMITS.STORAGE_KEY) || '{}');
        if (rateLimitData.date === today) {
          document.getElementById('daily-request-count').textContent = rateLimitData.count || 0;
        }
      });

      // Content Type Configuration
      const CONTENT_TYPES = {
        linkedin: { 
          id: 'linkedin', 
          label: 'LinkedIn Post', 
          textField: 'linkedin_text', 
          statusField: 'linkedin_status',
          enableField: 'enable_linkedin',
          backendTextKey: 'linkedin_text',      
          backendStatusKey: 'linkedin_status',
          postingEnabled: true
        },
        instagram: { 
          id: 'instagram', 
          label: 'Instagram Feed', 
          textField: 'insta_text', 
          statusField: 'insta_status',
          enableField: 'enable_instagram',
          backendTextKey: 'insta_feed_text',    
          backendStatusKey: 'insta_feed_status',
          postingEnabled: false // Noch nicht implementiert
        },
        instagram_reel: { 
          id: 'instagram_reel', 
          label: 'Instagram Reel', 
          textField: 'insta_reel_text', 
          statusField: 'insta_reel_status',
          enableField: 'enable_instagram_reel',
          backendTextKey: 'insta_reel_text',    
          backendStatusKey: 'insta_reel_status',
          postingEnabled: false
        },
        facebook: { 
          id: 'facebook', 
          label: 'Facebook Post', 
          textField: 'facebook_text', 
          statusField: 'facebook_status',
          enableField: 'enable_facebook',
          backendTextKey: 'facebook_text',      
          backendStatusKey: 'facebook_status',
          postingEnabled: true
        },
        blog: { 
          id: 'blog', 
          label: 'Blog Artikel', 
          textField: 'blog_text', 
          statusField: 'blog_status',
          enableField: 'enable_blog',
          backendTextKey: 'blog_text',          
          backendStatusKey: 'blog_status',
          postingEnabled: false
        },
        podcast: {
          id: 'podcast',
          label: 'Podcast Skript',
          textField: 'podcast_text',
          statusField: 'podcast_status', 
          enableField: 'enable_podcast',
          backendTextKey: 'podcast_text',       
          backendStatusKey: 'podcast_status',
          postingEnabled: true // Text-to-Speech
        },
        avatar: {
          id: 'avatar',
          label: 'Avatar Skript',
          textField: 'avatar_text',
          statusField: 'avatar_status',
          enableField: 'enable_avatar', 
          backendTextKey: 'avatar_text',        
          backendStatusKey: 'avatar_status',
          postingEnabled: false
        }
      };

      // Base64 Functions
      function encodeBase64Text(text) {
        try {
          if (!text || text.trim() === '') return '';
          const utf8Bytes = new TextEncoder().encode(text);
          const binaryString = String.fromCharCode(...utf8Bytes);
          return btoa(binaryString);
        } catch (error) {
          console.error("‚ùå Base64 Encode Fehler:", error);
          return text;
        }
      }

      function decodeBase64Text(base64String) {
        try {
          if (!base64String || base64String.trim() === '') return '';
          const binaryString = atob(base64String);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          return new TextDecoder('utf-8').decode(bytes);
        } catch (error) {
          console.error("‚ùå Base64 Decode Fehler:", error);
          try {
            return atob(base64String);
          } catch (fallbackError) {
            return base64String;
          }
        }
      }

      function autoResize(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.max(100, textarea.scrollHeight) + 'px';
      }

      // Enhanced Validation & Submission
      async function submitInputWithValidation() {
        // Rate limiting check
        if (!checkRateLimit()) {
          return;
        }
        
        const thema = document.getElementById("thema").value.trim();
        if (!thema) {
          showErrorMessage("Bitte f√ºllen Sie das Thema-Feld aus.");
          return;
        }

        const selectedChannels = getSelectedChannels();
        if (selectedChannels.length === 0) {
          showErrorMessage("Bitte w√§hlen Sie mindestens einen Content-Kanal aus.");
          return;
        }

        const channelNames = selectedChannels.map(ch => CONTENT_TYPES[ch].label).join(', ');
        if (!confirm(`Content wird generiert f√ºr: ${channelNames}. Fortfahren?`)) return;

        const payload = {
          input_id: inputId,
          thema: thema,
          subline: document.getElementById("subline").value,
          url: document.getElementById("url").value,
          grafik_url: document.getElementById("grafik_url").value,
          selected_channels: selectedChannels
        };

        await executeSubmission(payload);
      }

      function getSelectedChannels() {
        return Object.keys(CONTENT_TYPES).filter(type => 
          document.getElementById(CONTENT_TYPES[type].enableField).checked
        );
      }

      async function executeSubmission(payload) {
        const webhookUrl = "https://hook.eu2.make.com/cv9u4q1t3exjr6wz196owrm4ud6atahl";

        try {
          showLoadingState(true);
          showProgressMessage("Content wird generiert...");
          
          const response = await fetch(webhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (response.ok) {
            updateRateLimit(); // Update rate limit after successful request
            showSuccessMessage("Erfolgreich gestartet! ‚úÖ");
            createContentSections(payload.selected_channels);
            showInfoMessage("‚è±Ô∏è Generation l√§uft ca. 2-3 Minuten...", true);
            
            setTimeout(async () => {
              await startIntelligentPolling();
            }, 30000);
            
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          console.error("Submission error:", error);
          showErrorMessage(`Fehler beim √úbertragen: ${error.message}`);
        } finally {
          showLoadingState(false);
        }
      }

      // Dynamic Content Sections with Posting Actions
      function createContentSections(selectedChannels) {
        const container = document.getElementById("content-sections-container");
        container.innerHTML = "";
        
        selectedChannels.forEach(channel => {
          const config = CONTENT_TYPES[channel];
          const sectionDiv = document.createElement('div');
          sectionDiv.id = `${channel}-section`;
          sectionDiv.className = 'content-section mb-6 p-4 border border-gray-200 rounded-lg';
          
          const postingButtons = config.postingEnabled ? `
            <div class="post-action-buttons">
              <button class="action-btn btn-post" onclick="postContent('${channel}')" disabled>
                üöÄ Sofort posten
              </button>
              <button class="action-btn btn-schedule" onclick="scheduleContent('${channel}')" disabled>
                üìÖ Planen
              </button>
              <button class="action-btn btn-draft" onclick="saveDraft('${channel}')" disabled>
                üìù Als Entwurf
              </button>
            </div>
          ` : `
            <div class="text-sm text-gray-500 mt-2">
              Automatisches Posting f√ºr diesen Kanal noch nicht verf√ºgbar
            </div>
          `;
          
          sectionDiv.innerHTML = `
            <div class="flex items-center justify-between mb-2">
              <label class="font-semibold text-lg">${config.label}:</label>
              <span class="status-badge px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-800">Wird generiert...</span>
            </div>
            <textarea id="${config.textField}" class="border w-full p-2 mt-1 auto-resize rounded" 
                      placeholder="${config.label} Content wird generiert..."
                      oninput="autoResize(this); updatePostingButtons('${channel}')"></textarea>
            <select id="${config.statusField}" class="mt-2 p-2 border w-full rounded" onchange="updatePostingButtons('${channel}')">
              <option value="pending">Auswahl treffen</option>
              <option value="yes">Freigeben</option>
              <option value="no">Ablehnen</option>
            </select>
            ${postingButtons}
          `;
          
          container.appendChild(sectionDiv);
        });
      }

      function updatePostingButtons(channel) {
        const config = CONTENT_TYPES[channel];
        const statusField = document.getElementById(config.statusField);
        const textField = document.getElementById(config.textField);
        const section = document.getElementById(`${channel}-section`);
        
        if (!section || !config.postingEnabled) return;
        
        const buttons = section.querySelectorAll('.action-btn');
        const isApproved = statusField.value === 'yes';
        const hasContent = textField.value.trim() !== '';
        
        buttons.forEach(btn => {
          btn.disabled = !(isApproved && hasContent);
        });
      }

      // Posting Functions
      async function postContent(channel) {
        const config = CONTENT_TYPES[channel];
        const content = document.getElementById(config.textField).value;
        const inputIdValue = document.getElementById("input_id").value;
        
        if (!confirm(`${config.label} sofort ver√∂ffentlichen?`)) return;
        
        try {
          showProgressMessage(`Ver√∂ffentliche ${config.label}...`);
          
          const webhookUrl = "https://hook.eu2.make.com/hw1siz7ad14nfv7tr4y0cte3l2rtkwxm";
          const response = await fetch(webhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              input_id: inputIdValue,
              mode: "post",
              channel: channel,
              content: escapeJsonString(content),
              action: "immediate"
            }),
          });
          
          if (response.ok) {
            showSuccessMessage(`‚úÖ ${config.label} erfolgreich ver√∂ffentlicht!`);
            updateSectionStatus(document.getElementById(`${channel}-section`), 'posted');
          } else {
            throw new Error(`HTTP ${response.status}`);
          }
        } catch (error) {
          showErrorMessage(`Fehler beim Ver√∂ffentlichen: ${error.message}`);
        }
      }

      async function scheduleContent(channel) {
        const config = CONTENT_TYPES[channel];
        const scheduleTime = prompt("Wann soll gepostet werden? (Format: YYYY-MM-DD HH:MM)");
        
        if (!scheduleTime) return;
        
        // TODO: Implement scheduling logic
        showInfoMessage(`‚è∞ ${config.label} f√ºr ${scheduleTime} geplant (Feature in Entwicklung)`);
      }

      async function saveDraft(channel) {
        const config = CONTENT_TYPES[channel];
        showInfoMessage(`üìù ${config.label} als Entwurf gespeichert (Feature in Entwicklung)`);
      }

      // Intelligent Polling System
      async function startIntelligentPolling() {
        let attempts = 0;
        const maxAttempts = 12;
        
        const poll = async () => {
          attempts++;
          console.log(`üîÑ Polling-Versuch ${attempts}/${maxAttempts}`);
          
          showInfoMessage(`üîÑ Pr√ºfe Content... (${attempts}/${maxAttempts})`, true);
          
          const success = await loadReview(true);
          
          if (success) {
            clearPersistentMessage();
            showSuccessMessage("‚úÖ Content ist da! Automatisch geladen.");
            return;
          }
          
          if (attempts < maxAttempts) {
            setTimeout(poll, 15000);
          } else {
            showWarningMessage("‚è±Ô∏è Maximale Wartezeit erreicht. Versuchen Sie 'Content laden'.");
          }
        };
        
        poll();
      }

      async function loadReview(silentMode = false) {
        const inputIdValue = document.getElementById("input_id").value;
        if (!inputIdValue) {
          if (!silentMode) showErrorMessage("Keine Input-ID vorhanden.");
          return false;
        }

        isPolling = true;
        const webhookUrl = `https://hook.eu2.make.com/hw1siz7ad14nfv7tr4y0cte3l2rtkwxm?mode=load&input_id=${inputIdValue}`;

        try {
          if (!silentMode) showProgressMessage("Lade Content...");
          
          const response = await fetch(webhookUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

          const responseText = await response.text();
          let data = JSON.parse(responseText);
          
          let hasGeneratedContent = false;
          
          Object.keys(CONTENT_TYPES).forEach(type => {
            const config = CONTENT_TYPES[type];
            
            let backendText = data[config.backendTextKey];
            const backendStatus = data[config.backendStatusKey];
            
            if (backendText) {
              backendText = decodeBase64Text(backendText);
            }
            
            const hasContent = backendText && backendText.trim() !== '';
            const sectionElement = document.getElementById(`${type}-section`);
            
            if (sectionElement && hasContent) {
              hasGeneratedContent = true;
              sectionElement.style.display = 'block';
              
              const textField = document.getElementById(config.textField);
              const statusField = document.getElementById(config.statusField);
              
              if (textField) {
                textField.value = backendText || "";
                autoResize(textField);
              }
              if (statusField) statusField.value = backendStatus || "pending";
              
              updateSectionStatus(sectionElement, backendStatus);
              updatePostingButtons(type);
            }
          });
          
          document.getElementById("review-submit-btn").style.display = hasGeneratedContent ? "block" : "none";
          
          if (hasGeneratedContent) {
            clearPersistentMessage();
            if (!silentMode) showSuccessMessage("‚úÖ Content erfolgreich geladen!");
            return true;
          } else {
            if (!silentMode) {
              showWarningMessage("‚ö†Ô∏è Noch kein Content verf√ºgbar. Content wird noch generiert...");
            }
            return false;
          }
          
        } catch (error) {
          console.error("‚ùå Fehler beim Laden der Review-Daten", error);
          if (!silentMode) showErrorMessage(`Fehler beim Laden des Contents: ${error.message}`);
          return false;
        } finally {
          isPolling = false;
        }
      }

      function updateSectionStatus(sectionDiv, status) {
        const statusBadge = sectionDiv.querySelector('.status-badge');
        if (statusBadge) {
          const statusConfig = {
            'pending': { text: 'Pending', class: 'bg-yellow-100 text-yellow-800' },
            'yes': { text: 'Freigegeben', class: 'bg-green-100 text-green-800' },
            'no': { text: 'Abgelehnt', class: 'bg-red-100 text-red-800' },
            'posted': { text: 'Ver√∂ffentlicht', class: 'bg-purple-100 text-purple-800' }
          };
          
          const config = statusConfig[status] || statusConfig['pending'];
          statusBadge.textContent = config.text;
          statusBadge.className = `status-badge px-3 py-1 rounded-full text-sm font-medium ${config.class}`;
        }
      }

      function escapeJsonString(str) {
        if (!str) return '';
        return str
          .replace(/\\/g, '\\\\')
          .replace(/"/g, '\\"')
          .replace(/\n/g, '\\n')
          .replace(/\r/g, '\\r')
          .replace(/\t/g, '\\t');
      }

      async function submitReview() {
        const payload = {
          input_id: document.getElementById("input_id").value,
          mode: "save"
        };

        const coreTypes = ['linkedin', 'instagram', 'facebook', 'blog'];
        
        coreTypes.forEach(type => {
          const config = CONTENT_TYPES[type];
          const textElement = document.getElementById(config.textField);
          const statusElement = document.getElementById(config.statusField);
          
          if (textElement && textElement.value.trim() !== '') {
            payload[config.textField] = escapeJsonString(textElement.value);
            payload[config.statusField] = statusElement.value;
          }
        });

        const webhookUrl = "https://hook.eu2.make.com/hw1siz7ad14nfv7tr4y0cte3l2rtkwxm";

        try {
          showLoadingState(true, "review-submit-btn");
          
          const response = await fetch(webhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (response.ok) {
            showSuccessMessage("Freigaben erfolgreich gespeichert ‚úÖ");
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          console.error("Review submission error:", error);
          showErrorMessage(`Fehler beim Speichern: ${error.message}`);
        } finally {
          showLoadingState(false, "review-submit-btn");
        }
      }

      // UI Helper Functions
      function showLoadingState(isLoading, buttonId = "submit-btn") {
        const button = document.getElementById(buttonId);
        if (button) {
          button.disabled = isLoading;
          if (isLoading) {
            button.innerHTML = '<div class="loading-spinner"></div>Wird verarbeitet...';
          } else {
            button.innerHTML = buttonId === "submit-btn" ? "Inhalt √ºbermitteln" : "Freigaben speichern";
          }
        }
      }

      function clearPersistentMessage() {
        const container = document.getElementById("status-container");
        const existing = container.querySelector('.status-message.persistent');
        if (existing) existing.remove();
      }

      function showStatusMessage(message, type, persistent = false) {
        const container = document.getElementById("status-container");
        
        if (!persistent) {
          const existing = container.querySelector('.status-message:not(.persistent)');
          if (existing) existing.remove();
        } else {
          const existing = container.querySelector('.status-message');
          if (existing) existing.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `status-message p-4 rounded-lg font-medium text-center ${persistent ? 'persistent' : ''}`;
        
        const styles = {
          info: 'bg-blue-50 text-blue-800 border border-blue-200',
          success: 'bg-green-50 text-green-800 border border-green-200',
          error: 'bg-red-50 text-red-800 border border-red-200',
          warning: 'bg-yellow-50 text-yellow-800 border border-yellow-200'
        };
        
        messageDiv.className += ` ${styles[type] || styles.info}`;
        messageDiv.textContent = message;
        
        container.appendChild(messageDiv);
        
        if ((type === 'success' || type === 'info') && !persistent) {
          setTimeout(() => {
            messageDiv.style.opacity = '0';
            setTimeout(() => messageDiv.remove(), 300);
          }, 8000);
        }
      }

      function showProgressMessage(message) { showStatusMessage(message, 'info'); }
      function showSuccessMessage(message) { showStatusMessage(message, 'success'); }
      function showErrorMessage(message) { showStatusMessage(message, 'error'); }
      function showWarningMessage(message) { showStatusMessage(message, 'warning'); }
      function showInfoMessage(message, persistent = false) { showStatusMessage(message, 'info', persistent); }

      function submitInput() {
        submitInputWithValidation();
      }
    </script>
  </body>
</html>