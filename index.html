<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Content Eingabe & Review</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      .status-message {
        transition: opacity 0.3s ease;
      }
      .status-message.persistent {
        /* Persistente Nachrichten bleiben sichtbar */
      }
      .loading-spinner {
        border: 2px solid #f3f3f3;
        border-top: 2px solid #3498db;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        animation: spin 1s linear infinite;
        display: inline-block;
        margin-right: 8px;
      }
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      .content-section {
        transition: all 0.3s ease;
      }
      .status-badge {
        transition: all 0.2s ease;
      }
      /* Auto-resize Textareas */
      .auto-resize {
        resize: vertical;
        overflow: hidden;
        min-height: 100px;
      }
    </style>
  </head>
  <body class="bg-gray-100 p-6">
    <!-- Status Message Container -->
    <div id="status-container" class="max-w-3xl mx-auto mb-4"></div>

    <!-- Content Input Section -->
    <div class="max-w-3xl mx-auto bg-white rounded-2xl shadow p-6 mb-8">
      <div class="flex items-center justify-between mb-4">
        <img src="https://anyever.de/wp-content/themes/anyever/static/images/logo-anyever-gold.svg" alt="Any Ever Logo" class="h-12" />
      </div>
      <h1 class="text-2xl font-bold mb-4">Content-Eingabe</h1>

      <input type="text" id="thema" class="border p-2 mb-4 w-full rounded" placeholder="Thema (Pflichtfeld)" required />
      <input type="text" id="subline" class="border p-2 mb-4 w-full rounded" placeholder="Subline (optional)" />
      <input type="url" id="url" class="border p-2 mb-4 w-full rounded" placeholder="Ziel-URL (optional)" />
      <input type="url" id="grafik_url" class="border p-2 mb-4 w-full rounded" placeholder="Grafik-URL (optional)" />

      <!-- Content Type Selection - Instagram Reel und Feed beieinander -->
      <div class="mb-4 p-4 bg-gray-50 rounded-lg">
        <h3 class="font-semibold mb-3">Content-Kan√§le ausw√§hlen (mindestens einen):</h3>
        <div class="grid grid-cols-2 gap-3">
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_linkedin" class="content-checkbox" checked />
            <span>LinkedIn Post</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_facebook" class="content-checkbox" checked />
            <span>Facebook Post</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_instagram" class="content-checkbox" checked />
            <span>Instagram Feed</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_instagram_reel" class="content-checkbox" />
            <span>Instagram Reel</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_blog" class="content-checkbox" checked />
            <span>Blog Artikel</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_podcast" class="content-checkbox" />
            <span>Podcast Skript</span>
          </label>
          <label class="flex items-center space-x-2">
            <input type="checkbox" id="enable_avatar" class="content-checkbox" />
            <span>Avatar Skript</span>
          </label>
        </div>
      </div>

      <div class="text-right">
        <button id="submit-btn" onclick="submitInputWithValidation()" class="bg-green-600 text-white px-6 py-3 rounded-xl shadow hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed font-medium">
          Inhalt √ºbermitteln
        </button>
      </div>
    </div>

    <!-- Content Review Section -->
    <div class="max-w-3xl mx-auto bg-white rounded-2xl shadow p-6">
      <h1 class="text-2xl font-bold mb-4">Content Review & Freigabe</h1>

      <!-- Versteckte Input-ID (technisch ben√∂tigt, aber f√ºr User irrelevant) -->
      <input type="text" id="input_id" style="position: absolute; left: -9999px; opacity: 0;" readonly />

      <!-- Dynamic Content Sections Container -->
      <div id="content-sections-container">
        <!-- Sections werden dynamisch erstellt basierend auf ausgew√§hlten Kan√§len -->
      </div>

      <div class="text-right">
        <button id="review-submit-btn" onclick="submitReview()" class="bg-blue-600 text-white px-6 py-3 rounded-xl shadow hover:bg-blue-700 font-medium" style="display: none;">
          Freigaben speichern
        </button>
      </div>
    </div>

    <script>
      // Global Variables
      const inputId = Date.now().toString();
      let isPolling = false;

      // Initialize
      document.addEventListener("DOMContentLoaded", () => {
        document.getElementById("input_id").value = inputId;
      });

      // ‚úÖ BASE64 ENCODER FUNKTION
      function encodeBase64Text(text) {
        try {
          if (!text || text.trim() === '') return '';
          
          // UTF-8 zu Base64
          const utf8Bytes = new TextEncoder().encode(text);
          const binaryString = String.fromCharCode(...utf8Bytes);
          return btoa(binaryString);
          
        } catch (error) {
          console.error("‚ùå Base64 Encode Fehler:", error);
          return text; // Fallback: urspr√ºnglichen Text zur√ºckgeben
        }
      }

      // ‚úÖ BASE64 DECODER FUNKTION - MIT KORREKTER UTF-8 UNTERST√úTZUNG
      function decodeBase64Text(base64String) {
        try {
          if (!base64String || base64String.trim() === '') return '';
          
          // Base64 dekodieren und UTF-8 korrekt behandeln
          const binaryString = atob(base64String);
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          
          // UTF-8 dekodieren
          return new TextDecoder('utf-8').decode(bytes);
          
        } catch (error) {
          console.error("‚ùå Base64 Decode Fehler:", error);
          // Fallback: normales atob() versuchen
          try {
            return atob(base64String);
          } catch (fallbackError) {
            return base64String; // Letzter Fallback
          }
        }
      }

      // Content Type Configuration
      const CONTENT_TYPES = {
        linkedin: { 
          id: 'linkedin', 
          label: 'LinkedIn Post', 
          textField: 'linkedin_text', 
          statusField: 'linkedin_status',
          enableField: 'enable_linkedin',
          backendTextKey: 'linkedin_text',      
          backendStatusKey: 'linkedin_status'
        },
        instagram: { 
          id: 'instagram', 
          label: 'Instagram Feed', 
          textField: 'insta_text', 
          statusField: 'insta_status',
          enableField: 'enable_instagram',
          backendTextKey: 'insta_feed_text',    
          backendStatusKey: 'insta_feed_status'  
        },
        instagram_reel: { 
          id: 'instagram_reel', 
          label: 'Instagram Reel', 
          textField: 'insta_reel_text', 
          statusField: 'insta_reel_status',
          enableField: 'enable_instagram_reel',
          backendTextKey: 'insta_reel_text',    
          backendStatusKey: 'insta_reel_status'  
        },
        facebook: { 
          id: 'facebook', 
          label: 'Facebook Post', 
          textField: 'facebook_text', 
          statusField: 'facebook_status',
          enableField: 'enable_facebook',
          backendTextKey: 'facebook_text',      
          backendStatusKey: 'facebook_status'
        },
        blog: { 
          id: 'blog', 
          label: 'Blog Artikel', 
          textField: 'blog_text', 
          statusField: 'blog_status',
          enableField: 'enable_blog',
          backendTextKey: 'blog_text',          
          backendStatusKey: 'blog_status'
        },
        podcast: {
          id: 'podcast',
          label: 'Podcast Skript',
          textField: 'podcast_text',
          statusField: 'podcast_status', 
          enableField: 'enable_podcast',
          backendTextKey: 'podcast_text',       
          backendStatusKey: 'podcast_status'    
        },
        avatar: {
          id: 'avatar',
          label: 'Avatar Skript',
          textField: 'avatar_text',
          statusField: 'avatar_status',
          enableField: 'enable_avatar', 
          backendTextKey: 'avatar_text',        
          backendStatusKey: 'avatar_status'     
        }
      };

      // Auto-resize Funktion f√ºr Textareas
      function autoResize(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.max(100, textarea.scrollHeight) + 'px';
      }

      // Persistente Nachrichten-Funktionen
      function clearPersistentMessage() {
        const container = document.getElementById("status-container");
        const existing = container.querySelector('.status-message.persistent');
        if (existing) existing.remove();
      }

      // Enhanced Validation & Submission
      async function submitInputWithValidation() {
        const thema = document.getElementById("thema").value.trim();
        if (!thema) {
          showErrorMessage("Bitte f√ºllen Sie das Thema-Feld aus.");
          return;
        }

        const selectedChannels = getSelectedChannels();
        if (selectedChannels.length === 0) {
          showErrorMessage("Bitte w√§hlen Sie mindestens einen Content-Kanal aus.");
          return;
        }

        const channelNames = selectedChannels.map(ch => CONTENT_TYPES[ch].label).join(', ');
        if (!confirm(`Content wird generiert f√ºr: ${channelNames}. Fortfahren?`)) return;

        const payload = {
          input_id: inputId,
          thema: thema,
          subline: document.getElementById("subline").value,
          url: document.getElementById("url").value,
          grafik_url: document.getElementById("grafik_url").value,
          selected_channels: selectedChannels
        };

        await executeSubmission(payload);
      }

      function getSelectedChannels() {
        return Object.keys(CONTENT_TYPES).filter(type => 
          document.getElementById(CONTENT_TYPES[type].enableField).checked
        );
      }

      async function executeSubmission(payload) {
        const webhookUrl = "https://hook.eu2.make.com/cv9u4q1t3exjr6wz196owrm4ud6atahl";

        try {
          showLoadingState(true);
          showProgressMessage("Content wird generiert...");
          
          const response = await fetch(webhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (response.ok) {
            showSuccessMessage("Erfolgreich gestartet! ‚úÖ");
            createContentSections(payload.selected_channels);
            // ‚úÖ INTELLIGENTES POLLING - startet nach 30 Sekunden
            showInfoMessage("‚è±Ô∏è Generation l√§uft ca. 2-3 Minuten...", true);
            
            setTimeout(async () => {
              await startIntelligentPolling();
            }, 30000); // Erste Pr√ºfung nach 30 Sekunden
            
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          console.error("Submission error:", error);
          showErrorMessage(`Fehler beim √úbertragen: ${error.message}`);
        } finally {
          showLoadingState(false);
        }
      }

      // ‚úÖ INTELLIGENTES POLLING SYSTEM
      async function startIntelligentPolling() {
        let attempts = 0;
        const maxAttempts = 12; // 12 x 15 Sekunden = 3 Minuten
        
        const poll = async () => {
          attempts++;
          console.log(`üîÑ Polling-Versuch ${attempts}/${maxAttempts}`);
          
          showInfoMessage(`üîÑ Pr√ºfe Content... (${attempts}/${maxAttempts})`, true);
          
          const success = await loadReview(true); // Silent mode
          
          if (success) {
            clearPersistentMessage();
            showSuccessMessage("‚úÖ Content ist da! Automatisch geladen.");
            return; // Erfolgreich - stoppe Polling
          }
          
          if (attempts < maxAttempts) {
            setTimeout(poll, 15000); // N√§chster Versuch in 15 Sekunden
          } else {
            showWarningMessage("‚è±Ô∏è Maximale Wartezeit erreicht. Versuchen Sie 'Content laden'.");
          }
        };
        
        poll(); // Starte das Polling
      }

      // Dynamic Content Sections
      function createContentSections(selectedChannels) {
        const container = document.getElementById("content-sections-container");
        container.innerHTML = "";
        
        selectedChannels.forEach(channel => {
          const config = CONTENT_TYPES[channel];
          const sectionDiv = document.createElement('div');
          sectionDiv.id = `${channel}-section`;
          sectionDiv.className = 'content-section mb-4 p-4 border border-gray-200 rounded-lg';
          
          sectionDiv.innerHTML = `
            <div class="flex items-center justify-between mb-2">
              <label class="font-semibold text-lg">${config.label}:</label>
              <span class="status-badge px-3 py-1 rounded-full text-sm font-medium bg-blue-100 text-blue-800">Wird generiert...</span>
            </div>
            <textarea id="${config.textField}" class="border w-full p-2 mt-1 auto-resize rounded" 
                      placeholder="${config.label} Content wird generiert..."
                      oninput="autoResize(this)"></textarea>
            <select id="${config.statusField}" class="mt-2 p-2 border w-full rounded">
              <option value="pending">Auswahl treffen</option>
              <option value="yes">Freigeben</option>
              <option value="no">Ablehnen</option>
            </select>
          `;
          
          container.appendChild(sectionDiv);
        });
      }

      async function manualLoadReview() {
        // Diese Funktion wird nicht mehr gebraucht, da automatisches Polling aktiv ist
        // Kann sp√§ter entfernt werden
        if (isPolling) {
          showWarningMessage("Bereits am Laden...");
          return;
        }
        await loadReview(false);
      }

      // Enhanced Load Review Function - MIT BASE64 DECODING
      async function loadReview(silentMode = false) {
        const inputIdValue = document.getElementById("input_id").value;
        if (!inputIdValue) {
          if (!silentMode) showErrorMessage("Keine Input-ID vorhanden.");
          return false;
        }

        isPolling = true;
        const webhookUrl = `https://hook.eu2.make.com/hw1siz7ad14nfv7tr4y0cte3l2rtkwxm?mode=load&input_id=${inputIdValue}`;

        try {
          if (!silentMode) showProgressMessage("Lade Content...");
          
          const response = await fetch(webhookUrl);
          if (!response.ok) throw new Error(`HTTP ${response.status}: ${response.statusText}`);

          const responseText = await response.text();
          console.log("üîç RAW RESPONSE:", responseText);
          
          // ‚úÖ ROBUSTE JSON-BEHANDLUNG
          let data;
          try {
            data = JSON.parse(responseText);
          } catch (parseError) {
            console.error("‚ùå JSON Parse Fehler:", parseError);
            if (!silentMode) showErrorMessage(`JSON-Fehler beim Laden des Contents. Fehler: ${parseError.message}`);
            return false;
          }
          
          console.log("üîç VOLLST√ÑNDIGE BACKEND-RESPONSE:", data);
          
          let hasGeneratedContent = false;
          
          Object.keys(CONTENT_TYPES).forEach(type => {
            const config = CONTENT_TYPES[type];
            
            let backendText = data[config.backendTextKey];
            const backendStatus = data[config.backendStatusKey];
            
            // ‚úÖ BASE64 DECODING + CONTENT BEREINIGUNG
            if (backendText) {
              console.log(`üîç ${config.label} - Original Base64:`, backendText.substring(0, 50) + "...");
              
              // Base64 dekodieren
              backendText = decodeBase64Text(backendText);
              
              console.log(`‚úÖ ${config.label} - Dekodiert:`, backendText.substring(0, 100) + "...");
            }
            
            console.log(`üìù ${config.label}:`, {
              hasContent: !!backendText,
              contentLength: backendText ? backendText.length : 0,
              status: backendStatus
            });
            
            const hasContent = backendText && backendText.trim() !== '';
            const sectionElement = document.getElementById(`${type}-section`);
            
            if (sectionElement) {
              if (hasContent) {
                hasGeneratedContent = true;
                sectionElement.style.display = 'block';
                
                const textField = document.getElementById(config.textField);
                const statusField = document.getElementById(config.statusField);
                
                if (textField) {
                  textField.value = backendText || "";
                  autoResize(textField);
                }
                if (statusField) statusField.value = backendStatus || "pending";
                
                updateSectionStatus(sectionElement, backendStatus);
                
                console.log(`‚úÖ ${config.label} Content geladen erfolgreich`);
              } else {
                console.log(`‚ùå ${config.label} Content NICHT vorhanden`);
                sectionElement.style.display = 'none';
              }
            }
          });
          
          document.getElementById("review-submit-btn").style.display = hasGeneratedContent ? "block" : "none";
          
          if (hasGeneratedContent) {
            clearPersistentMessage();
            if (!silentMode) showSuccessMessage("‚úÖ Content erfolgreich geladen!");
            return true;
          } else {
            if (!silentMode) {
              showWarningMessage("‚ö†Ô∏è Noch kein Content verf√ºgbar. Content wird noch generiert...");
              console.log("üí° VERF√úGBARE KEYS:", Object.keys(data));
            }
            return false;
          }
          
        } catch (error) {
          console.error("‚ùå Fehler beim Laden der Review-Daten", error);
          if (!silentMode) showErrorMessage(`Fehler beim Laden des Contents: ${error.message}`);
          return false;
        } finally {
          isPolling = false;
        }
      }

      function updateSectionStatus(sectionDiv, status) {
        const statusBadge = sectionDiv.querySelector('.status-badge');
        if (statusBadge) {
          const statusConfig = {
            'pending': { text: 'Pending', class: 'bg-yellow-100 text-yellow-800' },
            'yes': { text: 'Freigegeben', class: 'bg-green-100 text-green-800' },
            'no': { text: 'Abgelehnt', class: 'bg-red-100 text-red-800' }
          };
          
          const config = statusConfig[status] || statusConfig['pending'];
          statusBadge.textContent = config.text;
          statusBadge.className = `status-badge px-3 py-1 rounded-full text-sm font-medium ${config.class}`;
        }
      }

      // ‚úÖ JSON ESCAPE FUNKTION
      function escapeJsonString(str) {
        if (!str) return '';
        return str
          .replace(/\\/g, '\\\\')  // Backslashes escapen
          .replace(/"/g, '\\"')    // Anf√ºhrungszeichen escapen
          .replace(/\n/g, '\\n')   // Newlines escapen
          .replace(/\r/g, '\\r')   // Carriage returns escapen
          .replace(/\t/g, '\\t');  // Tabs escapen
      }

      // Submit Review Function - MIT JSON ESCAPING
      async function submitReview() {
        const payload = {
          input_id: document.getElementById("input_id").value,
          mode: "save"
        };

        // NUR die urspr√ºnglichen Felder senden
        const coreTypes = ['linkedin', 'instagram', 'facebook', 'blog'];
        
        coreTypes.forEach(type => {
          const config = CONTENT_TYPES[type];
          const textElement = document.getElementById(config.textField);
          const statusElement = document.getElementById(config.statusField);
          
          if (textElement && textElement.value.trim() !== '') {
            // ‚úÖ JSON-ESCAPING f√ºr sicheren Transport
            payload[config.textField] = escapeJsonString(textElement.value);
            payload[config.statusField] = statusElement.value;
          }
        });

        const webhookUrl = "https://hook.eu2.make.com/hw1siz7ad14nfv7tr4y0cte3l2rtkwxm";

        try {
          showLoadingState(true, "review-submit-btn");
          console.log("üíæ Speichere nur Core-Felder:", payload);
          
          const response = await fetch(webhookUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
          });

          if (response.ok) {
            showSuccessMessage("Freigaben erfolgreich gespeichert ‚úÖ");
          } else {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }
        } catch (error) {
          console.error("Review submission error:", error);
          showErrorMessage(`Fehler beim Speichern: ${error.message}`);
        } finally {
          showLoadingState(false, "review-submit-btn");
        }
      }

      // UI Helper Functions
      function showLoadingState(isLoading, buttonId = "submit-btn") {
        const button = document.getElementById(buttonId);
        if (button) {
          button.disabled = isLoading;
          if (isLoading) {
            button.innerHTML = '<div class="loading-spinner"></div>Wird verarbeitet...';
          } else {
            button.innerHTML = buttonId === "submit-btn" ? "Inhalt √ºbermitteln" : "Freigaben speichern";
          }
        }
      }

      function showStatusMessage(message, type, persistent = false) {
        const container = document.getElementById("status-container");
        
        if (!persistent) {
          const existing = container.querySelector('.status-message:not(.persistent)');
          if (existing) existing.remove();
        } else {
          const existing = container.querySelector('.status-message');
          if (existing) existing.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `status-message p-4 rounded-lg font-medium text-center ${persistent ? 'persistent' : ''}`;
        
        const styles = {
          info: 'bg-blue-50 text-blue-800 border border-blue-200',
          success: 'bg-green-50 text-green-800 border border-green-200',
          error: 'bg-red-50 text-red-800 border border-red-200',
          warning: 'bg-yellow-50 text-yellow-800 border border-yellow-200'
        };
        
        messageDiv.className += ` ${styles[type] || styles.info}`;
        messageDiv.textContent = message;
        
        container.appendChild(messageDiv);
        
        if ((type === 'success' || type === 'info') && !persistent) {
          setTimeout(() => {
            messageDiv.style.opacity = '0';
            setTimeout(() => messageDiv.remove(), 300);
          }, 8000);
        }
      }

      function showProgressMessage(message) { showStatusMessage(message, 'info'); }
      function showSuccessMessage(message) { showStatusMessage(message, 'success'); }
      function showErrorMessage(message) { showStatusMessage(message, 'error'); }
      function showWarningMessage(message) { showStatusMessage(message, 'warning'); }
      function showInfoMessage(message, persistent = false) { showStatusMessage(message, 'info', persistent); }

      function submitInput() {
        submitInputWithValidation();
      }
    </script>
  </body>
</html>